{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport fs from \"fs\";\nimport path from \"path\";\nimport matter from \"gray-matter\";\nimport { serialize } from \"next-mdx-remote/serialize\";\nimport readingTime from \"reading-time\";\nimport mdxPrism from \"mdx-prism\";\nconst root = process.cwd();\nexport const getFiles = async (type) => fs.readdirSync(path.join(root, \"data\", type));\nexport const getFileBySlug = async (type, slug) => {\n  const mdxSource = slug ? fs.readFileSync(path.join(root, \"data\", type, `${slug}.mdx`), \"utf8\") : fs.readFileSync(path.join(root, \"data\", `${type}.mdx`), \"utf8\");\n  const {\n    data,\n    content\n  } = await matter(mdxSource);\n  const source = await serialize(content, {\n    mdxOptions: {\n      remarkPlugins: [require(\"remark-code-titles\")],\n      rehypePlugins: [mdxPrism]\n    }\n  });\n  return {\n    source,\n    frontmatter: _objectSpread({\n      readingTime: readingTime(content),\n      slug: slug || null\n    }, data)\n  };\n};\nexport const getAllFilesFrontMatter = async type => {\n  const files = fs.readdirSync(path.join(root, \"data\", type));\n  return files.reduce((allPosts, postSlug) => {\n    const mdxSource = fs.readFileSync(path.join(root, \"data\", type, postSlug), \"utf8\");\n    const {\n      data\n    } = matter(mdxSource);\n    return [_objectSpread(_objectSpread({}, data), {}, {\n      slug: postSlug.replace(\".mdx\", \"\")\n    }), ...allPosts];\n  }, []);\n};","map":{"version":3,"sources":["/Users/jordy/Documents/GitHub/webside/lib/mdx.js"],"names":["fs","path","matter","serialize","readingTime","mdxPrism","root","process","cwd","getFiles","type","readdirSync","join","getFileBySlug","slug","mdxSource","readFileSync","data","content","source","mdxOptions","remarkPlugins","require","rehypePlugins","frontmatter","getAllFilesFrontMatter","files","reduce","allPosts","postSlug","replace"],"mappings":";;;;;;AAAA,OAAOA,EAAP,MAAe,IAAf;AACA,OAAOC,IAAP,MAAiB,MAAjB;AACA,OAAOC,MAAP,MAAmB,aAAnB;AACA,SAASC,SAAT,QAA0B,2BAA1B;AACA,OAAOC,WAAP,MAAwB,cAAxB;AACA,OAAOC,QAAP,MAAqB,WAArB;AAEA,MAAMC,IAAI,GAAGC,OAAO,CAACC,GAAR,EAAb;AAEA,OAAO,MAAMC,QAAQ,GAAG,OAAOC,IAAP,KACtBV,EAAE,CAACW,WAAH,CAAeV,IAAI,CAACW,IAAL,CAAUN,IAAV,EAAgB,MAAhB,EAAwBI,IAAxB,CAAf,CADK;AAGP,OAAO,MAAMG,aAAa,GAAG,OAAOH,IAAP,EAAaI,IAAb,KAAsB;AACjD,QAAMC,SAAS,GAAGD,IAAI,GAClBd,EAAE,CAACgB,YAAH,CAAgBf,IAAI,CAACW,IAAL,CAAUN,IAAV,EAAgB,MAAhB,EAAwBI,IAAxB,EAA+B,GAAEI,IAAK,MAAtC,CAAhB,EAA8D,MAA9D,CADkB,GAElBd,EAAE,CAACgB,YAAH,CAAgBf,IAAI,CAACW,IAAL,CAAUN,IAAV,EAAgB,MAAhB,EAAyB,GAAEI,IAAK,MAAhC,CAAhB,EAAwD,MAAxD,CAFJ;AAIA,QAAM;AAAEO,IAAAA,IAAF;AAAQC,IAAAA;AAAR,MAAoB,MAAMhB,MAAM,CAACa,SAAD,CAAtC;AAEA,QAAMI,MAAM,GAAG,MAAMhB,SAAS,CAACe,OAAD,EAAU;AACtCE,IAAAA,UAAU,EAAE;AACVC,MAAAA,aAAa,EAAE,CAACC,OAAO,CAAC,oBAAD,CAAR,CADL;AAEVC,MAAAA,aAAa,EAAE,CAAClB,QAAD;AAFL;AAD0B,GAAV,CAA9B;AAOA,SAAO;AACLc,IAAAA,MADK;AAELK,IAAAA,WAAW;AACTpB,MAAAA,WAAW,EAAEA,WAAW,CAACc,OAAD,CADf;AAETJ,MAAAA,IAAI,EAAEA,IAAI,IAAI;AAFL,OAGNG,IAHM;AAFN,GAAP;AAQD,CAtBM;AAwBP,OAAO,MAAMQ,sBAAsB,GAAG,MAAOf,IAAP,IAAgB;AACpD,QAAMgB,KAAK,GAAG1B,EAAE,CAACW,WAAH,CAAeV,IAAI,CAACW,IAAL,CAAUN,IAAV,EAAgB,MAAhB,EAAwBI,IAAxB,CAAf,CAAd;AAEA,SAAOgB,KAAK,CAACC,MAAN,CAAa,CAACC,QAAD,EAAWC,QAAX,KAAwB;AAC1C,UAAMd,SAAS,GAAGf,EAAE,CAACgB,YAAH,CAChBf,IAAI,CAACW,IAAL,CAAUN,IAAV,EAAgB,MAAhB,EAAwBI,IAAxB,EAA8BmB,QAA9B,CADgB,EAEhB,MAFgB,CAAlB;AAIA,UAAM;AAAEZ,MAAAA;AAAF,QAAWf,MAAM,CAACa,SAAD,CAAvB;AAEA,WAAO,iCAEAE,IAFA;AAGHH,MAAAA,IAAI,EAAEe,QAAQ,CAACC,OAAT,CAAiB,MAAjB,EAAyB,EAAzB;AAHH,QAKL,GAAGF,QALE,CAAP;AAOD,GAdM,EAcJ,EAdI,CAAP;AAeD,CAlBM","sourcesContent":["import fs from \"fs\";\nimport path from \"path\";\nimport matter from \"gray-matter\";\nimport { serialize } from \"next-mdx-remote/serialize\";\nimport readingTime from \"reading-time\";\nimport mdxPrism from \"mdx-prism\";\n\nconst root = process.cwd();\n\nexport const getFiles = async (type) =>\n  fs.readdirSync(path.join(root, \"data\", type));\n\nexport const getFileBySlug = async (type, slug) => {\n  const mdxSource = slug\n    ? fs.readFileSync(path.join(root, \"data\", type, `${slug}.mdx`), \"utf8\")\n    : fs.readFileSync(path.join(root, \"data\", `${type}.mdx`), \"utf8\");\n\n  const { data, content } = await matter(mdxSource);\n\n  const source = await serialize(content, {\n    mdxOptions: {\n      remarkPlugins: [require(\"remark-code-titles\")],\n      rehypePlugins: [mdxPrism],\n    },\n  });\n\n  return {\n    source,\n    frontmatter: {\n      readingTime: readingTime(content),\n      slug: slug || null,\n      ...data,\n    },\n  };\n};\n\nexport const getAllFilesFrontMatter = async (type) => {\n  const files = fs.readdirSync(path.join(root, \"data\", type));\n\n  return files.reduce((allPosts, postSlug) => {\n    const mdxSource = fs.readFileSync(\n      path.join(root, \"data\", type, postSlug),\n      \"utf8\"\n    );\n    const { data } = matter(mdxSource);\n\n    return [\n      {\n        ...data,\n        slug: postSlug.replace(\".mdx\", \"\"),\n      },\n      ...allPosts,\n    ];\n  }, []);\n};\n"]},"metadata":{},"sourceType":"module"}