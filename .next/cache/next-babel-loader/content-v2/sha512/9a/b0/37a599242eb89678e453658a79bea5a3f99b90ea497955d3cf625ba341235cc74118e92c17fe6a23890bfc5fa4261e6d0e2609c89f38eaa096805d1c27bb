{"ast":null,"code":"// extracted from https://usehooks-typescript.com/react-hook/use-intersection-observer\nimport { useRef, useEffect, useState } from \"react\";\nexport function useIntersectionObserver({\n  elementRef,\n  threshold = 0.1,\n  root = null,\n  rootMargin = \"0%\",\n  freezeOnceVisible = false\n}) {\n  const observer = useRef(null);\n  const {\n    0: entry,\n    1: setEntry\n  } = useState();\n  const isClient = false;\n  const hasIOSupport = isClient && !!window.IntersectionObserver;\n  const noUpdate = (entry === null || entry === void 0 ? void 0 : entry.isIntersecting) && freezeOnceVisible;\n  const IOOptions = {\n    threshold,\n    root,\n    rootMargin\n  };\n\n  const updateEntry = ([entry]) => {\n    setEntry(entry);\n  };\n\n  useEffect(function initIntersectionObserver() {\n    // DOM Ref\n    const node = elementRef === null || elementRef === void 0 ? void 0 : elementRef.current;\n\n    if (!hasIOSupport || noUpdate || !node) {\n      return;\n    } // delete the old observer before creating a new one\n\n\n    if (observer.current) observer.current.disconnect(); // eslint-disable-next-line no-undef\n\n    observer.current = new IntersectionObserver(updateEntry, IOOptions); // ensure the rest of useEffect use the same observer\n\n    const {\n      current: currentObserver\n    } = observer;\n    currentObserver.observe(node);\n    return () => {\n      currentObserver.disconnect();\n    };\n  }, [elementRef, threshold, root, rootMargin, noUpdate]);\n  return [!!(entry !== null && entry !== void 0 && entry.isIntersecting), entry];\n}","map":{"version":3,"sources":["/Users/jordy/Documents/GitHub/webside/lib/use-intersection-observer.js"],"names":["useRef","useEffect","useState","useIntersectionObserver","elementRef","threshold","root","rootMargin","freezeOnceVisible","observer","entry","setEntry","isClient","hasIOSupport","window","IntersectionObserver","noUpdate","isIntersecting","IOOptions","updateEntry","initIntersectionObserver","node","current","disconnect","currentObserver","observe"],"mappings":"AAAA;AACA,SAASA,MAAT,EAAiBC,SAAjB,EAA4BC,QAA5B,QAA4C,OAA5C;AAEA,OAAO,SAASC,uBAAT,CAAiC;AACtCC,EAAAA,UADsC;AAEtCC,EAAAA,SAAS,GAAG,GAF0B;AAGtCC,EAAAA,IAAI,GAAG,IAH+B;AAItCC,EAAAA,UAAU,GAAG,IAJyB;AAKtCC,EAAAA,iBAAiB,GAAG;AALkB,CAAjC,EAMJ;AACD,QAAMC,QAAQ,GAAGT,MAAM,CAAC,IAAD,CAAvB;AACA,QAAM;AAAA,OAACU,KAAD;AAAA,OAAQC;AAAR,MAAoBT,QAAQ,EAAlC;AACA,QAAMU,QAAQ,QAAd;AACA,QAAMC,YAAY,GAAGD,QAAQ,IAAI,CAAC,CAACE,MAAM,CAACC,oBAA1C;AACA,QAAMC,QAAQ,GAAG,CAAAN,KAAK,SAAL,IAAAA,KAAK,WAAL,YAAAA,KAAK,CAAEO,cAAP,KAAyBT,iBAA1C;AAEA,QAAMU,SAAS,GAAG;AAAEb,IAAAA,SAAF;AAAaC,IAAAA,IAAb;AAAmBC,IAAAA;AAAnB,GAAlB;;AAEA,QAAMY,WAAW,GAAG,CAAC,CAACT,KAAD,CAAD,KAAa;AAC/BC,IAAAA,QAAQ,CAACD,KAAD,CAAR;AACD,GAFD;;AAIAT,EAAAA,SAAS,CACP,SAASmB,wBAAT,GAAoC;AAClC;AACA,UAAMC,IAAI,GAAGjB,UAAH,aAAGA,UAAH,uBAAGA,UAAU,CAAEkB,OAAzB;;AAEA,QAAI,CAACT,YAAD,IAAiBG,QAAjB,IAA6B,CAACK,IAAlC,EAAwC;AACtC;AACD,KANiC,CAQlC;;;AACA,QAAIZ,QAAQ,CAACa,OAAb,EAAsBb,QAAQ,CAACa,OAAT,CAAiBC,UAAjB,GATY,CAUlC;;AACAd,IAAAA,QAAQ,CAACa,OAAT,GAAmB,IAAIP,oBAAJ,CAAyBI,WAAzB,EAAsCD,SAAtC,CAAnB,CAXkC,CAalC;;AACA,UAAM;AAAEI,MAAAA,OAAO,EAAEE;AAAX,QAA+Bf,QAArC;AACAe,IAAAA,eAAe,CAACC,OAAhB,CAAwBJ,IAAxB;AAEA,WAAO,MAAM;AACXG,MAAAA,eAAe,CAACD,UAAhB;AACD,KAFD;AAGD,GArBM,EAsBP,CAACnB,UAAD,EAAaC,SAAb,EAAwBC,IAAxB,EAA8BC,UAA9B,EAA0CS,QAA1C,CAtBO,CAAT;AAyBA,SAAO,CAAC,CAAC,EAACN,KAAD,aAACA,KAAD,eAACA,KAAK,CAAEO,cAAR,CAAF,EAA0BP,KAA1B,CAAP;AACD","sourcesContent":["// extracted from https://usehooks-typescript.com/react-hook/use-intersection-observer\nimport { useRef, useEffect, useState } from \"react\";\n\nexport function useIntersectionObserver({\n  elementRef,\n  threshold = 0.1,\n  root = null,\n  rootMargin = \"0%\",\n  freezeOnceVisible = false,\n}) {\n  const observer = useRef(null);\n  const [entry, setEntry] = useState();\n  const isClient = typeof window !== \"undefined\";\n  const hasIOSupport = isClient && !!window.IntersectionObserver;\n  const noUpdate = entry?.isIntersecting && freezeOnceVisible;\n\n  const IOOptions = { threshold, root, rootMargin };\n\n  const updateEntry = ([entry]) => {\n    setEntry(entry);\n  };\n\n  useEffect(\n    function initIntersectionObserver() {\n      // DOM Ref\n      const node = elementRef?.current;\n\n      if (!hasIOSupport || noUpdate || !node) {\n        return;\n      }\n\n      // delete the old observer before creating a new one\n      if (observer.current) observer.current.disconnect();\n      // eslint-disable-next-line no-undef\n      observer.current = new IntersectionObserver(updateEntry, IOOptions);\n\n      // ensure the rest of useEffect use the same observer\n      const { current: currentObserver } = observer;\n      currentObserver.observe(node);\n\n      return () => {\n        currentObserver.disconnect();\n      };\n    },\n    [elementRef, threshold, root, rootMargin, noUpdate]\n  );\n\n  return [!!entry?.isIntersecting, entry];\n}\n"]},"metadata":{},"sourceType":"module"}