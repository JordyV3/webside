{"ast":null,"code":"import _slicedToArray from \"/Users/jordy/Documents/GitHub/webside/node_modules/next/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nvar _s = $RefreshSig$();\n\n// extracted from https://usehooks-typescript.com/react-hook/use-intersection-observer\nimport { useRef, useEffect, useState } from \"react\";\nexport function useIntersectionObserver(_ref) {\n  _s();\n\n  var elementRef = _ref.elementRef,\n      _ref$threshold = _ref.threshold,\n      threshold = _ref$threshold === void 0 ? 0.1 : _ref$threshold,\n      _ref$root = _ref.root,\n      root = _ref$root === void 0 ? null : _ref$root,\n      _ref$rootMargin = _ref.rootMargin,\n      rootMargin = _ref$rootMargin === void 0 ? \"0%\" : _ref$rootMargin,\n      _ref$freezeOnceVisibl = _ref.freezeOnceVisible,\n      freezeOnceVisible = _ref$freezeOnceVisibl === void 0 ? false : _ref$freezeOnceVisibl;\n  var observer = useRef(null);\n\n  var _useState = useState(),\n      entry = _useState[0],\n      setEntry = _useState[1];\n\n  var isClient = true;\n  var hasIOSupport = isClient && !!window.IntersectionObserver;\n  var noUpdate = (entry === null || entry === void 0 ? void 0 : entry.isIntersecting) && freezeOnceVisible;\n  var IOOptions = {\n    threshold: threshold,\n    root: root,\n    rootMargin: rootMargin\n  };\n\n  var updateEntry = function updateEntry(_ref2) {\n    var _ref3 = _slicedToArray(_ref2, 1),\n        entry = _ref3[0];\n\n    setEntry(entry);\n  };\n\n  useEffect(function initIntersectionObserver() {\n    // DOM Ref\n    var node = elementRef === null || elementRef === void 0 ? void 0 : elementRef.current;\n\n    if (!hasIOSupport || noUpdate || !node) {\n      return;\n    } // delete the old observer before creating a new one\n\n\n    if (observer.current) observer.current.disconnect(); // eslint-disable-next-line no-undef\n\n    observer.current = new IntersectionObserver(updateEntry, IOOptions); // ensure the rest of useEffect use the same observer\n\n    var currentObserver = observer.current;\n    currentObserver.observe(node);\n    return function () {\n      currentObserver.disconnect();\n    };\n  }, [elementRef, threshold, root, rootMargin, noUpdate]);\n  return [!!(entry !== null && entry !== void 0 && entry.isIntersecting), entry];\n}\n\n_s(useIntersectionObserver, \"TmmvGr1DKndwVhaD5IkzGLDRnew=\");","map":{"version":3,"sources":["/Users/jordy/Documents/GitHub/webside/lib/use-intersection-observer.js"],"names":["useRef","useEffect","useState","useIntersectionObserver","elementRef","threshold","root","rootMargin","freezeOnceVisible","observer","entry","setEntry","isClient","hasIOSupport","window","IntersectionObserver","noUpdate","isIntersecting","IOOptions","updateEntry","initIntersectionObserver","node","current","disconnect","currentObserver","observe"],"mappings":";;;;AAAA;AACA,SAASA,MAAT,EAAiBC,SAAjB,EAA4BC,QAA5B,QAA4C,OAA5C;AAEA,OAAO,SAASC,uBAAT,OAMJ;AAAA;;AAAA,MALDC,UAKC,QALDA,UAKC;AAAA,4BAJDC,SAIC;AAAA,MAJDA,SAIC,+BAJW,GAIX;AAAA,uBAHDC,IAGC;AAAA,MAHDA,IAGC,0BAHM,IAGN;AAAA,6BAFDC,UAEC;AAAA,MAFDA,UAEC,gCAFY,IAEZ;AAAA,mCADDC,iBACC;AAAA,MADDA,iBACC,sCADmB,KACnB;AACD,MAAMC,QAAQ,GAAGT,MAAM,CAAC,IAAD,CAAvB;;AADC,kBAEyBE,QAAQ,EAFjC;AAAA,MAEMQ,KAFN;AAAA,MAEaC,QAFb;;AAGD,MAAMC,QAAQ,OAAd;AACA,MAAMC,YAAY,GAAGD,QAAQ,IAAI,CAAC,CAACE,MAAM,CAACC,oBAA1C;AACA,MAAMC,QAAQ,GAAG,CAAAN,KAAK,SAAL,IAAAA,KAAK,WAAL,YAAAA,KAAK,CAAEO,cAAP,KAAyBT,iBAA1C;AAEA,MAAMU,SAAS,GAAG;AAAEb,IAAAA,SAAS,EAATA,SAAF;AAAaC,IAAAA,IAAI,EAAJA,IAAb;AAAmBC,IAAAA,UAAU,EAAVA;AAAnB,GAAlB;;AAEA,MAAMY,WAAW,GAAG,SAAdA,WAAc,QAAa;AAAA;AAAA,QAAXT,KAAW;;AAC/BC,IAAAA,QAAQ,CAACD,KAAD,CAAR;AACD,GAFD;;AAIAT,EAAAA,SAAS,CACP,SAASmB,wBAAT,GAAoC;AAClC;AACA,QAAMC,IAAI,GAAGjB,UAAH,aAAGA,UAAH,uBAAGA,UAAU,CAAEkB,OAAzB;;AAEA,QAAI,CAACT,YAAD,IAAiBG,QAAjB,IAA6B,CAACK,IAAlC,EAAwC;AACtC;AACD,KANiC,CAQlC;;;AACA,QAAIZ,QAAQ,CAACa,OAAb,EAAsBb,QAAQ,CAACa,OAAT,CAAiBC,UAAjB,GATY,CAUlC;;AACAd,IAAAA,QAAQ,CAACa,OAAT,GAAmB,IAAIP,oBAAJ,CAAyBI,WAAzB,EAAsCD,SAAtC,CAAnB,CAXkC,CAalC;;AAbkC,QAcjBM,eAdiB,GAcGf,QAdH,CAc1Ba,OAd0B;AAelCE,IAAAA,eAAe,CAACC,OAAhB,CAAwBJ,IAAxB;AAEA,WAAO,YAAM;AACXG,MAAAA,eAAe,CAACD,UAAhB;AACD,KAFD;AAGD,GArBM,EAsBP,CAACnB,UAAD,EAAaC,SAAb,EAAwBC,IAAxB,EAA8BC,UAA9B,EAA0CS,QAA1C,CAtBO,CAAT;AAyBA,SAAO,CAAC,CAAC,EAACN,KAAD,aAACA,KAAD,eAACA,KAAK,CAAEO,cAAR,CAAF,EAA0BP,KAA1B,CAAP;AACD;;GA7CeP,uB","sourcesContent":["// extracted from https://usehooks-typescript.com/react-hook/use-intersection-observer\nimport { useRef, useEffect, useState } from \"react\";\n\nexport function useIntersectionObserver({\n  elementRef,\n  threshold = 0.1,\n  root = null,\n  rootMargin = \"0%\",\n  freezeOnceVisible = false,\n}) {\n  const observer = useRef(null);\n  const [entry, setEntry] = useState();\n  const isClient = typeof window !== \"undefined\";\n  const hasIOSupport = isClient && !!window.IntersectionObserver;\n  const noUpdate = entry?.isIntersecting && freezeOnceVisible;\n\n  const IOOptions = { threshold, root, rootMargin };\n\n  const updateEntry = ([entry]) => {\n    setEntry(entry);\n  };\n\n  useEffect(\n    function initIntersectionObserver() {\n      // DOM Ref\n      const node = elementRef?.current;\n\n      if (!hasIOSupport || noUpdate || !node) {\n        return;\n      }\n\n      // delete the old observer before creating a new one\n      if (observer.current) observer.current.disconnect();\n      // eslint-disable-next-line no-undef\n      observer.current = new IntersectionObserver(updateEntry, IOOptions);\n\n      // ensure the rest of useEffect use the same observer\n      const { current: currentObserver } = observer;\n      currentObserver.observe(node);\n\n      return () => {\n        currentObserver.disconnect();\n      };\n    },\n    [elementRef, threshold, root, rootMargin, noUpdate]\n  );\n\n  return [!!entry?.isIntersecting, entry];\n}\n"]},"metadata":{},"sourceType":"module"}